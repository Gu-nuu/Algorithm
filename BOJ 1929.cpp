#include <stdio.h>
#include <iostream>
#define MAX 1000001
using namespace std;

//보통 소수를 구하는 문제였을 때 단순히 한 수에 대해 나눠지는 수가 있는지를 판별하는 식으로 구했었는데 이 문제에서는 시간 초과가 나왔다.
//시간 초과를 해결하기 위해서는 입력이나 출력이 아니라 소수를 구하는 방식을 바꿔야했는데 이 과정에서 에라토스테네스의 체를 사용했다.
//에라토스테네스의 체는 소수를 구하는 빠른 알고리즘 중 하나이다. 우선 소수인지 아닌지를 확인할 0으로 초기화된 배열을 하나 만든다. 이때
//1일 때는 소수가 아닌 수, 0일 때는 소수이다. 1은 소수가 아니므로 우선적으로 제외한다. 2부터 작업이 이루어지는데 자기 자신을 제외하고 자신의 배수를
//모두 소수가 아닌 수로 간주한다는 개념이 매우 중요하다. 즉 2는 소수이기 때문에 0으로 표기하고 2의 배수는 모두 1로 표기한다. 그리고 3도 소수이므로
//0으로 표기하고 그 배수들은 모두 1로 표기한다. 8 같은 경우는 소수가 아닌데 이미 2의 배수를 검사할 때 일반적인 수로 표기했으므로 검사하지 않고
//넘어간다. 이와 같은 방식으로 0과 1로 수를 표기한 후 0으로 표기된 숫자들만 출력한다면 소수를 검사할 수 있다.

int arr[MAX]={0,};      //소수의 여부를 확인할 배열. 소수는 0, 소수가 아닌 수는 1로 표시한다.

int main()
{
    ios::ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);

    arr[1]=1;       //1은 소수가 아니므로 1로 표시

    int M,N;
    cin>>M>>N;

    for(int i=2; i<=N; i++)
    {
        if(arr[i]==1)       //만약 이미 검사하여 소수가 아닌 수로 확인되었다면 그 배수는 확인할 필요가 없다.
            continue;

        for(int j=2; i*j<=N; j++)       //소수가 아닌 경우 1로 만들어주는데, 이때 i와 j를 잘 보면 자기 자신을 제외한 그 다음 배수부터 1로 만들어주는 것을 확인할 수 있다.
            arr[i*j]=1;
    }

    for(int i=M; i<=N; i++)     //해당하는 범위 내에서 0으로 표시된 수열은 소수이므로 이를 찾아 출력해준다.
    {
        if(!arr[i])
            cout<<i<<"\n";
    }

    //1978번과 다르게 수를 벡터에 모두 넣고 시작하지 않고 해당 수에 대해 바로바로 소수인지 아닌지를 체크할 수 있도록 하였다.
    //하지만 여기선 시간초과가 나왔다...

    // while(true)
    // {
    //     if(M==N)
    //         break;
        
    //     bool check=true;
        
    //     if(M==1)
    //     {
    //         M++;
    //         continue;
    //     }

    //     for(int i=2; i<M; i++)
    //     {
    //         if(M%i==0)       //소수는 1과 자기 자신으로만 나눠지는 수이기 때문에 그 외의 수로 나눠진다면 소수가 아니다.
    //         {
    //             check=false;
    //             break;
    //         }
    //     }

    //     if(check==true)          //위 조건에 걸리지 않아서 소수의 조건을 만족했다면 출력한다.
    //         cout<<M<<"\n";
        
    //     M++;
    // }
    

    return 0;
}